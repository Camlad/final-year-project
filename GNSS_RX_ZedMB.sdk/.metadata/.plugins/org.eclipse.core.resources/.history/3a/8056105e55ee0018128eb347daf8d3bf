/*
 * spi.c
 *
 *  Created on: 21 Nov 2018
 *      Author: Anyone
 */
#include "defines.h"
#include "FreeRTOS.h"
#include "timers.h"
#include "xil_io.h"
#include "xspi_l.h"		/* SPI device driver */
#include "spi.h"
#include "NT1065.h"
#include "xspi.h"

#define BUFFER_SIZE 45UL
uint8_t ReadBuffer[BUFFER_SIZE];
uint8_t WriteBuffer[BUFFER_SIZE];

void spiTask( void *pvParameters )
{
	const TickType_t x1second = pdMS_TO_TICKS( DELAY_1_SECOND );
	uint8_t outReg = 0x80;
	uint8_t inReg[2];
	uint8_t NT1065_readRegs[BUFFER_SIZE];
	uint16_t NT1065_readBuff[BUFFER_SIZE];
	uint8_t NT1065_writeRegs[BUFFER_SIZE];
	uint32_t Count;
	XSpi mySPI;
	XSpi *SpiInstancePtr;
	XSpi_Config *ConfigPtr;
	XStatus Status = XST_SUCCESS;
	uint32_t options = XSP_MASTER_OPTION;
	uint8_t Test;

	/*
	 * Initialize the SPI driver so that it is  ready to use.
	 */
	SpiInstancePtr = &mySPI;
	ConfigPtr = XSpi_LookupConfig(XPAR_AXI_QUAD_SPI_0_DEVICE_ID);
	if (ConfigPtr == NULL) {
		return XST_DEVICE_NOT_FOUND;
	}

	Status = XSpi_CfgInitialize(SpiInstancePtr, ConfigPtr,
				  ConfigPtr->BaseAddress);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	/*
	 * Perform a self-test to ensure that the hardware was built correctly.
	 */
	Status = XSpi_SelfTest(SpiInstancePtr);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	/*
	 * Run loopback test only in case of standard SPI mode.
	 */
	if (SpiInstancePtr->SpiMode != XSP_STANDARD_MODE) {
		return XST_SUCCESS;
	}

	/*
	 * Set the Spi device as a master
	 */
	Status = XSpi_SetOptions(SpiInstancePtr, XSP_MASTER_OPTION);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	XSpi_SetSlaveSelect(SpiInstancePtr, 1);

	/*
	 * Start the SPI driver so that the device is enabled.
	 */
	XSpi_Start(SpiInstancePtr);

	/*
	 * Disable Global interrupt to use polled mode operation
	 */
	XSpi_IntrGlobalDisable(SpiInstancePtr);


	for( ;; )
	{
		/* Delay for 1 second. */
		vTaskDelay( x1second );

		// read the spi data
		for(int i = 0; i < BUFFER_SIZE; i++)
		{
			Status = XSpi_Transfer(SpiInstancePtr, &outReg, &inReg, 2);
			xil_printf("SPI task reg%d = %x \r\n", outReg & 0x7F, inReg[1]);
			NT1065_writeRegs[i] = outReg;
			outReg = outReg + 1;
		}
		outReg = 0x80;

		XSpi_Transfer(SpiInstancePtr, &NT1065_writeRegs, &NT1065_readBuff, 2*BUFFER_SIZE);
		for(int i = 0; i < BUFFER_SIZE; i++)
		{
			NT1065_readRegs[i] = (uint8_t)(NT1065_readBuff[i]>>8);
		}
	}
}
